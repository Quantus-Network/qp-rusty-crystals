//! # Threshold ML-DSA Signature Scheme
//!
//! This crate implements threshold variants of the ML-DSA (Dilithium) signature scheme
//! as described in "Efficient Threshold ML-DSA up to 6 parties".
//!
//! ## Overview
//!
//! Threshold signatures allow a group of parties to collectively sign a message
//! without any single party having access to the complete signing key. This
//! implementation supports threshold signing with up to 6 parties for ML-DSA-87.
//!
//! ## Security Level
//!
//! The implementation provides ML-DSA-87 (256-bit security, NIST Level 5):
//! - Ring dimension N = 256
//! - Matrix dimensions k = 8, l = 7
//! - Supports (t,n) thresholds where 2 â‰¤ t â‰¤ n â‰¤ 6
//!
//! ## Usage
//!
//! ```rust,ignore
//! use qp_rusty_crystals_threshold::ml_dsa_87::{ThresholdConfig, generate_threshold_key, combine_signatures};
//! use qp_rusty_crystals_threshold::params::MlDsa87Params;
//!
//! // Setup threshold parameters: 2-of-3 threshold scheme
//! let config = ThresholdConfig::new(2, 3).expect("Invalid parameters");
//! let seed = [42u8; 32];
//!
//! // Generate threshold keys
//! let (threshold_pk, threshold_sks) = generate_threshold_key(&seed, &config)
//!     .expect("Key generation failed");
//!
//! // In a real threshold protocol, parties would generate Round1 states,
//! // exchange commitments, and compute responses. For testing purposes,
//! // mock data can be generated:
//! let commitment_size = config.threshold_params().commitment_size::<MlDsa87Params>();
//! let response_size = config.threshold_params().response_size::<MlDsa87Params>();
//!
//! // Generate mock threshold data (for testing only)
//! let commitments = vec![
//!     generate_mock_commitment(0, commitment_size),
//!     generate_mock_commitment(1, commitment_size),
//! ];
//! let responses = vec![
//!     generate_mock_response(0, response_size),
//!     generate_mock_response(1, response_size),
//! ];
//!
//! // Combine into threshold signature
//! let message = b"Hello, threshold world!";
//! let context = b"";
//! let threshold_signature = combine_signatures(
//!     &threshold_pk,
//!     message,
//!     context,
//!     &commitments,
//!     &responses,
//!     &config,
//! ).expect("Signature combination failed");
//! ```
//!
//! ## Implementation Status
//!
//! ### âœ… **Working Components:**
//! - **Threshold key generation**: Generates proper threshold keys from deterministic seeds
//! - **ML-DSA format compliance**: Produces signatures with correct ML-DSA-87 byte format (4627 bytes)
//! - **Internal constraint validation**: Passes ML-DSA coefficient bounds (Î³â‚-Î², Î³â‚‚-Î² limits)
//! - **Lagrange interpolation**: Proper secret sharing reconstruction using Lagrange coefficients
//! - **Round1 state generation**: Creates proper commitment and masking polynomial states
//! - **Signature combination**: Aggregates threshold shares into final signature format
//! - **Parameter validation**: Validates threshold configurations and sizes
//!
//! ### ðŸš§ **Partially Working:**
//! - **Mock data generation**: Works for testing internal components and format validation
//! - **Challenge generation**: Produces valid challenge format but may have compatibility issues
//! - **Hint computation**: Generates hint structures but uses simplified zero-hints approach
//!
//! ### âŒ **Known Limitations:**
//! - **Cryptographic verification**: Signatures fail verification by qp-rusty-crystals-dilithium crate
//! - **Full threshold protocol**: Complete Round2/Round3 coordination not implemented
//! - **Real-world compatibility**: Format mismatch between real Round1State data and mock responses
//! - **Production readiness**: Not suitable for production use due to verification failures
//!
//! ## Testing Status
//!
//! The test suite validates:
//! - âœ… Size calculations and signature format (4627 bytes)
//! - âœ… Internal ML-DSA constraint checking
//! - âœ… Challenge and hint structure formatting
//! - âœ… Threshold parameter validation
//! - âŒ Cryptographic verification (ignored test - known to fail)
//!
//! ## Next Steps for Full Implementation
//!
//! To complete the implementation for production use:
//!
//! 1. **Fix cryptographic verification**: Investigate why signatures fail dilithium crate verification
//! 2. **Implement complete Round2/Round3**: Build full threshold protocol coordination
//! 3. **Fix format compatibility**: Resolve mismatch between real commitments and responses
//! 4. **Add security review**: Comprehensive cryptographic security audit
//! 5. **Optimize performance**: Remove placeholder implementations and add proper NTT operations
//!
//! ## Research and Experimentation Warning
//!
//! **This implementation is for research and experimentation purposes only.**
//! **It has not undergone security review and MUST NOT be used in production systems.**
//! **Signatures generated by this crate do not currently pass cryptographic verification.**

#![cfg_attr(not(feature = "std"), no_std)]
#![deny(unsafe_code)]
#![warn(missing_docs, rust_2018_idioms)]

// Public API module for ML-DSA-87 security level
pub mod ml_dsa_87;

// Internal modules (circl_ntt made public for cross-language NTT testing)
pub mod circl_ntt;
mod common;
pub mod field;
pub mod params;

// Re-export common types and errors
pub use common::{ThresholdError, ThresholdResult};

// Convenience re-export for the main security level
pub use ml_dsa_87 as threshold;

// Additional alias for compatibility
pub use ml_dsa_87 as mldsa87;

/// Maximum number of parties supported by the threshold scheme
pub const MAX_PARTIES: u8 = 6;

/// Minimum threshold value (at least 2 parties required)
pub const MIN_THRESHOLD: u8 = 2;

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_constants() {
		assert!(MAX_PARTIES >= MIN_THRESHOLD);
		assert!(MIN_THRESHOLD >= 2);
	}
}
